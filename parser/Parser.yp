%start feature

%{
my %matchers;
%}

%%

feature                  : header feature_elements
                         ;

feature_elements         : scenarios
                         ;

scenarios                : scenario scenarios
                         | scenario
                         ;

scenario                 : scenario_keyword line_to_eol steps
                         ;

steps                    : step steps
                         | step
                         ;

step                     : step_keyword line_to_eol
{
   foreach my $regexp (keys %matchers) {
     if (my @subgroups = ("$_[1] $_[2]" =~ $regexp)) {
       $matchers{$regexp}->(@subgroups);
       last;
     }
   }
}
                         ;

%%

sub Lexer {
  my ($parser) = shift;

  # check to see if data to be parsed is present
  $parser->YYData->{INPUT} or return('',undef);

  # clean leading whitespace
  $parser->YYData->{INPUT} =~ s/^[\s\t]+//s;

  for ($parser->YYData->{INPUT}) {
    return ('header',           $1) if s/^Feature(.+?)Scenario/Scenario/so;
    return ('scenario_keyword', $1) if s/^(Scenario\s*?:)//so;
    return ('step_keyword',     $1) if s/^(Given|When|Then|And|But)//so;
    return ('line_to_eol',      $1) if s/^([^\n\r]+)//so;
  }
}

sub Error {
  my ($parser) = shift;
  exists $parser->YYData->{ERRMSG}
  and do {
    print $parser->YYData->{ERRMSG};
    delete $parser->YYData->{ERRMSG};
    return;
  };
  print "Syntax error: expecting \"",$parser->YYExpect,
        "\" but got \"",$parser->YYCurtok,"\"\n";
  print $parser->YYData->{ERRMSG};
}

sub parse {
  my ($self, $input, $ref_matchers) = @_;
  %matchers = %$ref_matchers;
  $self->YYData->{INPUT} = $input;
  my $result = $self->YYParse(yylex => \&Lexer, yyerror => \&Error, yydebug => 0x0);
  return $result;
}

# vim:syn=perl:
